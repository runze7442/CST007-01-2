/*
 Navicat Premium Dump SQL

 Source Server         : MySQL84_Test
 Source Server Type    : MySQL
 Source Server Version : 80403 (8.4.3)
 Source Host           : localhost:3306
 Source Schema         : top_news

 Target Server Type    : MySQL
 Target Server Version : 80403 (8.4.3)
 File Encoding         : 65001

 Date: 29/10/2024 13:01:17
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for news_headline
-- ----------------------------
DROP TABLE IF EXISTS `news_headline`;
CREATE TABLE `news_headline`  (
  `hid` int NOT NULL AUTO_INCREMENT COMMENT 'id',
  `title` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '标题',
  `article` varchar(10000) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '新闻内容',
  `type` int NOT NULL COMMENT '类型id',
  `publisher` int NOT NULL COMMENT '发布用户id',
  `page_views` int NOT NULL COMMENT '浏览量',
  `create_time` datetime NULL DEFAULT NULL COMMENT '发布时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '最后的修改时间',
  `is_deleted` int NULL DEFAULT NULL COMMENT '被删除 1 删除  0 未删除',
  PRIMARY KEY (`hid`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 19 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of news_headline
-- ----------------------------
INSERT INTO `news_headline` VALUES (1, '全面解释人工智能LLM模型的真实工作原理（完结）', '序言： 本节作为整篇的收官之作，自然少不了与当今最先进的AI模型相呼应。这里我们将简单介绍全球首家推动人工智能生成人类语言的公司——OpenAI的GPT模型的基本原理。如果你也希望为人类的发展做出贡献，并投身于AI行业，这无疑是一个绝佳的起点。其他知识都是进入该行业的基础，而理解该模型是必须的。OpenAI的创始团队中包括科技巨头Elon Musk，以及2024年诺贝尔奖得主Geoffrey Hinton的学生伊利亚·苏茨克弗（Ilya Sutskever）。他们都是全球有钱又最具智慧和前瞻性的人物代表。OpenAI最初公开了ChatGPT-2的语言模型（LLM）源代码，但在随后的ChatGPT-3及之后的版本中停止了开源，逐渐背离了最初的开放承诺，导致公司内部核心成员的相继离开。本节介绍的模型由OpenAI参与者、现任斯坦福大学教授李飞飞的学生Andrej Karpathy基于ChatGPT3模型而来。\r\n\r\n（关注不迷路，及时收到最新的人工智能资料更新）\r\n\r\nGPT架构\r\n\r\n接下来谈谈GPT架构。大多数GPT模型（尽管有不同的变化）都使用这种架构。如果你跟着文章读到这里，这部分应该相对容易理解。使用框图表示法，这就是GPT架构的高级示意图：\r\n\r\n\r\n\r\n此时，除了“GPT Transformer块”，其他模块我们都已详细讨论过。这里的+号只是表示两个向量相加（这意味着两个嵌入必须同样大小）。来看一下这个GPT Transformer块：\r\n\r\n\r\n\r\n就是这样。之所以称之为“Transformer”，是因为它源自并属于一种Transformer架构——我们将在下一节中详细了解。理解上没有影响，因为这里展示的所有模块我们都已讨论过。让我们回顾一下到目前为止构建这个GPT架构的过程：\r\n\r\n• 我们了解到神经网络接收数字并输出其他数字，权重是可训练的参数\r\n\r\n• 我们可以对这些输入/输出数字进行解释，赋予神经网络现实世界的意义\r\n\r\n• 我们可以串联神经网络创建更大的网络，并可以将每一个称为“块”，用框来表示以简化图解。每个块的作用都是接收一组数字并输出另一组数字\r\n\r\n• 我们学习了很多不同类型的块，每种块都有其不同的作用\r\n\r\n• GPT只是这些块的一个特殊排列，如上图所示，解释方式在第一部分已讨论过\r\n\r\n随着时间的推移，人们在此基础上做出了各种修改，使得现代LLM更加强大，但基本原理保持不变。\r\n\r\n现在，这个GPT Transformer实际上在原始Transformer论文中被称为“解码器”。让我们看看这一点。\r\n\r\nTransformer架构\r\n\r\n这是驱动语言模型能力迅速提升的关键创新之一。Transformer不仅提高了预测准确性，还比先前的模型更高效（更容易训练），允许构建更大的模型。这是GPT架构的基础。\r\n\r\n观察GPT架构，你会发现它非常适合生成序列中的下一个词。它基本遵循我们在第一部分讨论的逻辑：从几个词开始，然后逐个生成词。但是，如果你想进行翻译呢？比如，你有一句德语句子（例如“Wo wohnst du?” = “Where do you live?”），你希望将其翻译成英语。我们该如何训练模型来完成这项任务？\r\n\r\n第一步，我们需要找到一种输入德语单词的方法，这意味着我们要扩展嵌入，包含德语和英语。我猜一种简单的输入方式是将德语句子和生成的英文句子连接起来，并将其输入上下文。为了让模型更容易理解，我们可以添加一个分隔符。每一步看起来像这样：\r\n\r\n\r\n\r\n这可以工作，但仍有改进空间：\r\n\r\n• 如果上下文长度固定，有时会丢失原始句子\r\n\r\n• 模型需要学习很多内容。包括两种语言，还需要知道是分隔符，它应该在此处开始翻译\r\n\r\n• 每次生成一个词时，都需要处理整个德语句子，存在不同偏移。这意味着相同内容的内部表示不同，模型应该能够通过这些表示进行翻译\r\n\r\nTransformer最初就是为此任务创建的，它由“编码器”和“解码器”组成——基本上是两个独立的模块。一个模块仅处理德语句子，生成中间表示（仍然是数值集合）——这被称为编码器。第二个模块生成单词（我们已经见过很多）。唯一的区别是，除了将已生成的单词输入解码器外，还将编码器输出的德语句子作为额外输入。也就是说，在生成语言时，它的上下文是已生成的所有单词加上德语句子。这个模块被称为解码器。\r\n\r\n这些编码器和解码器由一些块组成，尤其是夹在其他层之间的注意力块。我们来看“Attention is all you need”论文中的Transformer架构示意图并尝试理解它：\r\n\r\n\r\n\r\n左侧的竖直块集合称为“编码器”，右侧的称为“解码器”。让我们逐个理解每个部分：\r\n\r\n前馈网络：前馈网络是没有循环的网络。第一部分中讨论的原始网络就是一个前馈网络。事实上，这个块采用了非常相似的结构。它包含两个线性层，每个层之后都有一个ReLU（见第一部分关于ReLU的介绍）和一个Dropout层。请记住，这个前馈网络适用于每个位置独立。也就是说，位置0有一个前馈网络，位置1有一个，依此类推。但是位置x的神经元不会与位置y的前馈网络相连。这样做的重要性在于防止网络在训练时“偷看”前方信息。\r\n\r\n交叉注意力：你会注意到解码器有一个多头注意力，其箭头来自编码器。这里发生了什么？记得自注意力和多头注意力中的value、key、query吗？它们都来自同一个序列。事实上，query只是序列的最后一个词。那么，如果我们保留query，但将value和key来自一个完全不同的序列会怎样？这就是这里发生的情况。value和key来自编码器的输出。数学上没有任何改变，只是key和value的输入来源发生了变化。\r\n\r\nNx：Nx表示这个块重复N次。基本上，你在将一个块层层堆叠，前一个块的输出作为下一个块的输入。这样可以使神经网络更深。从图上看，编码器输出如何传递给解码器可能让人困惑。假设N=5。我们是否将每层编码器输出传递给对应的解码器层？不是的。实际上你只需运行一次编码器，然后将同一表示提供给5个解码器层。\r\n\r\n加与归一化块：这与下方相同（作者似乎只是为了节省空间）。\r\n\r\n\r\n\r\n其他内容我们已经讨论过。现在你已经完整理解了Transformer架构，从简单的加法和乘法操作一步步构建到现在的完整自包含解释！你知道如何从头构建Transformer的每一行、每一加法、每一块和每个单词的意义。如果你感兴趣，可以参看这个开源库（开源GPT: https://github.com/karpathy/nanoGPT），它从头实现了上述的GPT架构。\r\n\r\n附录\r\n\r\n矩阵乘法\r\n\r\n在嵌入部分中，我们引入了向量和矩阵的概念。矩阵有两个维度（行数和列数）。向量也可以看作一个只有一个维度的矩阵。两个矩阵的乘积定义为：\r\n\r\n\r\n\r\n点表示相乘。现在我们再看一下第一张图中蓝色和有机神经元的计算。如果我们将权重写成矩阵，输入作为向量，可以将整个运算表示如下：\r\n\r\n\r\n如果权重矩阵称为“W”，输入称为“x”，则Wx为结果（在此情况下是中间层）。我们也可以将两者转置写作xW——这是个人偏好的问题。\r\n\r\n标准差\r\n\r\n在层归一化部分，我们使用了标准差的概念。标准差是一个统计量，用于描述数值的分布范围（在一组数字中），例如，如果所有值都相同，则标准差为零。如果每个值都与这些值的均值相距很远，则标准差会很高。计算一组数字a1, a2, a3…（假设有N个数字）的标准差的公式如下：将每个数字减去均值，然后将每个N个数字的结果平方。将所有这些数字相加，然后除以N，最后对结果开平方根。\r\n\r\n位置编码\r\n\r\n我们在上文中提到过位置嵌入。位置编码与嵌入向量长度相同，不同之处在于它不是嵌入，且无需训练。我们为每个位置分配一个独特的向量。例如，位置1是一个向量，位置2是另一个，以此类推。\r\n\r\n(完结)', 5, 1, 5, '2024-10-27 15:32:05', '2024-10-27 15:32:05', 0);
INSERT INTO `news_headline` VALUES (2, '【Vue】详解Vue组件系统\r\n\r\n', 'Vue渲染的两大基础方式\r\nnew 一个Vue的实例\r\n这个我们一般会使用在挂载根节点这一初始化操作上：\r\n\r\nnew Vue({\r\n  el: \'#app\'\r\n})\r\n \r\n\r\n注册组件并使用\r\n通过Vue.component（）去注册一个组件，你就可以全局地使用它了，具体体现在每个被new的 Vue\r\n\r\n实例/注册组件， 的template选项属性或者对应的DOM模板中,去直接使用\r\n\r\n \r\n\r\n回到顶部\r\n注册组件\r\n全局注册\r\n例如，放在通过new创建的Vue实例当中：\r\n\r\n复制代码\r\nVue.component(\'my-component\', {\r\n  template: \'<p>我是被全局注册的组件</p>\'\r\n})\r\n/*\r\n  Vue.component(组件名称[字符串], 组件对象)\r\n*/\r\n\r\nnew Vue({\r\n  el: \'#app\',\r\n  template: \'<my-component></my-component>\'\r\n})\r\n复制代码\r\n \r\n\r\ndemo:\r\n\r\n \r\n\r\n \r\n\r\n又例如，放在另外一个组件中：\r\n\r\n复制代码\r\nVue.component(\'my-component\', {\r\n  template: \'<p>我是被全局注册的组件</p>\'\r\n})\r\n\r\nVue.component(\'other-component\', {\r\n  template: \'<div>我是另一个全局组件：<my-component></my-component></div>\'\r\n})\r\n\r\nnew Vue({\r\n  el: \'#app\',\r\n  template: \'<other-component></other-component>\'\r\n})\r\n复制代码\r\n \r\n\r\n \r\n\r\n \r\n\r\n局部注册\r\n复制代码\r\nconst child = {\r\n  template: \'<p>我是局部注册的组件</p>\'\r\n}\r\n/*\r\n   通过components选项属性进行局部注册：\r\n   components: {\r\n    组件名称[字符串]: 组件对象\r\n  }\r\n*/\r\nnew Vue({\r\n  el: \'#app\',\r\n  template: \'<my-component></my-component>\',\r\n  components: {\r\n    \'my-component\': child\r\n  }\r\n})\r\n复制代码\r\ndemo:\r\n\r\n \r\n\r\n \r\n\r\n通过组件组合（嵌套），构建大型的应用：\r\n\r\n复制代码\r\nconst child = {\r\n  template: \'<p>我是child组件</p>\'\r\n}\r\n\r\nconst father = {\r\n  template: \'<p>我是father组件，我包含了：<child-component></child-component></p>\',\r\n  components: {\r\n    \'child-component\': child\r\n  }\r\n}\r\n\r\nconst grandFather = {\r\n  template: \'<p>我是grandFather组件，我包含了：<father-component></father-component></p>\',\r\n  components: {\r\n    \'father-component\': father\r\n  }\r\n}\r\n\r\nnew Vue({\r\n  el: \'#app\',\r\n  template: \'<my-component></my-component>\',\r\n  components: {\r\n    \'my-component\': grandFather\r\n  }\r\n})\r\n复制代码\r\n \r\n\r\ndemo:\r\n\r\n \r\n\r\n通过new创建Vue实例,  全局注册组件，局部注册组件三者的使用频率（场景）\r\n1.new  Vue（）,  尽管在Vue官方文档上在相当多的例子中使用到了创建Vue实例这个操作，实际上它的使用可能并没有你想象的那么平凡，在很多时候，它可能就只在挂载根实例的时候使用到\r\n\r\n \r\n\r\n【这段话给写react框架的人看】\r\n\r\n对 new Vue()做个最简单的描述！：在使用上类似于ReactDOM.render()...对，就是那个一开始你撸文档的时候觉得好像很重要，但最后发现在整个APP中就只使用了一次的那个顶层API ....\r\n\r\n \r\n\r\n2.全局注册组件的使用也不太频繁，首先来说，如果大量使用全局注册的话，当然容易产生组件的命名冲突，这就意味着你在构建大型组件的时候，你不应该选择用全局注册构建具体的细颗粒度的组件（实际上即使是小型应用也不推荐啦~~~）\r\n\r\n那么全局注册组件会在哪里使用到呢？\r\n\r\n2.1 有许多可全局复用的公共UI组件，你可能希望通过Vue.component({ ...})的方式全局注册它\r\n\r\n2.2 可以很简单地添加第三方UI框架\r\n\r\n【对比】大凡使用过一些UI框架的人，都知道一般情况下，使用这些UI组件的方式就是为元素添加类，像这样：\r\n\r\n \r\n\r\n<div class=\'UI框架中定义的类名\'></div>\r\n而在Vue中，你可以通过直接使用组件名称去使用，就和react相关的UI框架一样\r\n\r\n \r\n\r\n3.大多数时候我们通过组件组合的方式构建页面的时候，运用的是局部注册，就像上文所提及的那样\r\n\r\n \r\n\r\n \r\n\r\n【注意点】\r\n\r\n1.注册组件必须发生在根实例初始化前\r\n\r\n2.data是函数！\r\n\r\n \r\n\r\n回到顶部\r\nVue中的props数据流\r\n【写给react学习者们看的】这跟react中设计非常类似，连名称都相同，所以学过react的同学看这里应该会很轻松吧~~\r\n\r\n \r\n\r\n这里要用到Vue的一个选项属性——props;\r\n\r\n通过在注册组件中声明需要使用的props，然后通过props中与模板中传入的对应的属性名，去取用这传入的值\r\n\r\n例子：\r\n\r\nmodel部分：\r\n\r\n复制代码\r\nVue.component(\'my-component\', {\r\n  props: [\'name\', \'birthTime\'],\r\n  template: \'<p>我叫：{{name}} 我出生于：{{birthTime}}</p>\',\r\n  created: function () {\r\n    console.log(\'在created钩子函数中被调用\')\r\n    console.log(\'我叫：\', this.name)\r\n    console.log(\'我出生于：\', this.birthTime)\r\n  }\r\n})\r\n\r\nnew Vue({\r\n  el: \'#app\'\r\n})\r\n复制代码\r\n \r\n\r\nHTML部分:\r\n\r\n<div id=\'app\'>\r\n   <my-component name=\"彭湖湾\" birth-time=\"1997 -06 - 06\"></my-component>\r\n<div id=\'app\'>\r\n \r\n\r\ndemo:\r\n\r\n \r\n\r\n \r\n\r\n你在注册组件的时候通过props选项声明了要取用的多个prop：\r\n\r\nprops: [\'name\', \'birthTime\'],\r\n \r\n\r\n然后在模板中通过属性传值的方式进行数据的注入：\r\n\r\n<my-component name=\"彭湖湾\" birth-time=\"1997 -06 - 06\"></my-component>\r\n \r\n\r\n再然后我们就可以在注册组件的模板中使用到props选项中声明的值了：\r\n\r\ntemplate: \'<p>我叫：{{name}} 我出生于：{{birthTime}}</p>\'\r\n \r\n\r\n这里要注意几个点：\r\n\r\nprops取值的方式\r\n1.如果是在注册组件的模板内部，直接通过prop的名称取就OK了，例如\r\n\r\ntemplate: \'<p>我叫：{{name}} 我出生于：{{birthTime}}</p>\'\r\n \r\n\r\n2.如果在注册组件的其他地方，用this.prop的方式取用，例如\r\n\r\nconsole.log(\'我叫：\', this.name)\r\n \r\n\r\nprops内写的是驼峰命名法，为什么在HTML（模板）中又用了短横线命名法？\r\n（camelCased VS kebab-case）\r\n\r\n \r\n\r\n首先我们知道，Vue组件的模板可以放在两个地方：\r\n\r\n1. Vue组件的template选项属性中，作为模板字符串\r\n\r\n2.放在index.html中，作为HTML\r\n\r\n \r\n\r\n这里的问题在于，HTML特性是不区分大小写的\r\n\r\n所以在Vue注册组件中通用的驼峰命名法，显然不适用于HTML中的Vue模板，所以\r\n\r\n在HTML中写入props属性，必须写短横线命名法（就是把原来props属性中的每个prop大写换成小写，并且在前面加个“-”)\r\n\r\n \r\n\r\n总结：\r\n\r\n1.在template选项属性中，可以写驼峰命名法，也可以写短横线命名法\r\n\r\n2.在HTML（模板）中，只能写短横线命名法，不能写驼峰\r\n\r\n \r\n\r\n下面我就来证明以上两点：\r\n\r\n对1\r\n\r\n复制代码\r\nVue.component(\'my-component\', {\r\n  props: [\'name\', \'birthTime\'],\r\n  template: \'<p>我叫：{{name}} 我出生于：{{birthTime}}</p>\',\r\n  created: function () {\r\n    console.log(\'在created钩子函数中被调用\')\r\n    console.log(\'我叫：\', this.name)\r\n    console.log(\'我出生于：\', this.birthTime)\r\n  }\r\n})\r\nnew Vue({\r\n  el: \'#app\',\r\n  template: \'<my-component name=\"彭湖湾\" birthTime=\"1997 -06 - 06\"></my-component>\'\r\n})\r\n复制代码\r\n \r\n\r\ndemo:\r\n\r\n \r\n\r\n \r\n\r\nname和birthTime都正常显示，这说明在template模板字符串中，是可以写驼峰的\r\n\r\n（请注意到一点：name既符合驼峰写法也符合短横线写法，而birthTime只符合驼峰写法）\r\n\r\n \r\n\r\nJS部分\r\n\r\n复制代码\r\nVue.component(\'my-component\', {\r\n  props: [\'name\', \'birthTime\'],\r\n  template: \'<p>我叫：{{name}} 我出生于：{{birthTime}}</p>\',\r\n  created: function () {\r\n    console.log(\'在created钩子函数中被调用\')\r\n    console.log(\'我叫：\', this.name)\r\n    console.log(\'我出生于：\', this.birthTime)\r\n  }\r\n})\r\n\r\n \r\n\r\nnew Vue({\r\n  el: \'#app\'\r\n})\r\n复制代码\r\n \r\n\r\nHTML（模板）部分\r\n\r\n<div id=\'app\'>\r\n       <my-component name=\"彭湖湾\" birthTime=\"1997 -06 - 06\"></my-component>\r\n</div>\r\n  \r\n\r\ndemo:\r\n\r\n \r\n\r\n \r\n\r\n这里有个有趣的现象：name对应的值可以正常地显示，但！birthTime不能\r\n\r\n这是因为上文提到的：\r\n\r\nname既符合驼峰写法也符合短横线写法，而birthTime只符合驼峰写法，不符合HTML要求的短横线写法\r\n\r\n \r\n\r\n使用v-bind的必要性：props不绑定的前提下,只能被作为字符串解析\r\n复制代码\r\nVue.component(\'my-component\', {\r\n  props: [\'number\'],\r\n  template: \'<p>检测number的类型</p>\',\r\n  created: function () {\r\n    console.log(typeof this.number)\r\n  }\r\n})\r\n\r\nnew Vue({\r\n  el: \'#app\',\r\n  template: \'<my-component number=\"1\"></my-component>\'\r\n})\r\n复制代码\r\n \r\n\r\ndemo:\r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\nnumber被检测为字符串，这表明在不加v-bind绑定的情况下，props接受到的都是字符串，（注：如果被作为javacript，”1“会被解析为Number的1，而” ‘1’ “才会被解析为String的1）\r\n\r\n \r\n\r\n没错，仅仅这一点就会让我们非常为难，所以，我们需要使用v-bind：\r\n\r\n当使用v-bind的时候,在模板中props将会被作为javascript解析：\r\n\r\n复制代码\r\nVue.component(\'my-component\', {\r\n  props: [\'number\'],\r\n  template: \'<p>检测number的类型</p>\',\r\n  created: function () {\r\n    console.log(typeof this.number)\r\n  }\r\n})\r\n\r\nnew Vue({\r\n  el: \'#app\',\r\n  template: \'<my-component v-bind:number=\"1\"></my-component>\'\r\n})\r\n复制代码\r\n \r\n\r\ndemo:\r\n\r\n \r\n\r\n \r\n\r\n这可能拓展我们对v-bind的认知：\r\n\r\n1.用v-bind一般是为了做数据的动态绑定\r\n\r\n2.有时v-bind并不为了实现点1，只是纯粹为了让字符串内的内容被当作JS解析罢了\r\n\r\n \r\n\r\n回到顶部\r\nVue的自定义事件\r\n自定义事件是我非常喜欢的Vue的一大特性！！！ 看文档的第一眼我就对它情有独钟（虽然那一天离现在也就几天而已的时间。。。）\r\n\r\n \r\n\r\n先展示代码和demo:\r\n\r\n复制代码\r\nVue.component(\'button-counter\', {\r\n  template: \'<button v-on:click=\"increment\">{{counter}}</button>\',\r\n  data: function () {\r\n    return {\r\n      counter: 0\r\n    }\r\n  },\r\n\r\n  methods: {\r\n    increment: function () {\r\n      this.counter += 1\r\n      this.$emit(\'increment-event\')\r\n    }\r\n  }\r\n}) \r\n\r\nnew Vue({\r\n  el: \'#app\',\r\n  data: {\r\n    totalCounter: 0\r\n  },\r\n\r\n  methods: {\r\n    total_increment: function () {\r\n      this.totalCounter += 1\r\n    }\r\n  }\r\n})\r\n复制代码\r\n \r\n\r\n模板HTML部分：\r\n\r\n复制代码\r\n<div id=\'app\'>\r\n      <button>{{ totalCounter }}</button>\r\n      </br>\r\n      <button-counter v-on:increment-event=\'total_increment\'></button-counter>\r\n      <button-counter v-on:increment-event=\'total_increment\'></button-counter>\r\n</div>\r\n复制代码\r\n \r\n\r\ndemo:\r\n\r\n下面两个按钮是两个相同的子组件，并和上面那个按钮共同组成了父组件。\r\n\r\n当点击任意一个子组件的按钮，使其加1，都会使得父组件+1,最终：父组件的数值 = 子组件的数值之和\r\n\r\n点击下方左边button\r\n\r\n \r\n\r\n 点击下方右边button\r\n\r\n\r\n\r\n \r\n\r\n\r\n\r\n \r\n\r\n \r\n\r\n \r\n\r\n自定义事件的原理\r\n通过$emit(event)触发一个自定义事件\r\n\r\n然后通过$on(event,callback) 去执行对应的callback(回调函数)\r\n\r\n（两个event是字符串，且必须名称相同）\r\n\r\n但$on不能在父组件中监听子组件抛出的事件，所以我们要做到这一点，可以在父组件的模板中使用到子组件的时候，直接用v-on绑定 （和$on作用效果一致） 就像上面那样：\r\n\r\n<button-counter v-on:increment-event=\'total_increment\'></button-counter>\r\n \r\n\r\n这样一来，自定义事件的雏形就变得和原生事件一样了 \r\n\r\n即使这样，上面的代码可能还是有些难理解，我认为比较重要的是这一段：\r\n\r\n \r\n\r\nincrement: function () {\r\n      this.counter += 1\r\n      this.$emit(\'increment-event\')\r\n  }\r\n \r\n\r\n因为我们对于事件的运用主要是：利用事件和函数绑定，从而在事件触发的时候能执行相印的函数\r\n\r\n所以！ 对于自定义事件，我们要解决的问题就是，“这个事件在什么时候被触发” 在上面的代码中，触发事件的时间（执行 this.$emit(\'increment-event\')的时间）\r\n\r\n就恰恰是执行this.counter += 1 的时候\r\n\r\n \r\n\r\n \r\n\r\n自定义事件的作用\r\n\r\n对此，我主要从两点阐述我的观点：（非官方文档内容，自己思考的，觉得不对的可以指出）：\r\n\r\n自定义事件的作用1 ——“重新定义”了事件监听机制的范围\r\n \r\n\r\nMDN是这样描述DOM事件的：“DOM事件被发送以通知代码已发生的有趣的事。每个事件都由基于Event接口的一个对象表示”\r\n\r\n在我看来：当你使用事件的时候，你可能试图做这样一件事情： 在某一个特定的时间节点（或场景）做某个操作，例如调用一个函数。 而定位这个“时间节点”或“场景”的，就是事件。而我们对事件最喜欢做的事情，就是把事件和某个函数给绑定起来\r\n\r\n 但我们可能一直都忽略了一个认知：我们认知范围内的事件，好像只有原生事件呀？例如click(点击)，focus（聚焦）,keydown（按键）\r\n\r\n \r\n\r\n我们认知内的事件，难道只有这些个固定的范围吗？点击是事件，按下键盘按钮是事件。那么，我们能不能人为地定义一个事件呢？ 例如上面的，我们通过代码处理，让\"某个数据增加1\"也作为一个事件，从而去触发一个函数呢？\r\n\r\n这，就是自定义事件的目的和魅力\r\n\r\n \r\n\r\n自定义事件的作用2 ——使得父子组件权责明确\r\n就让我们看一下 父组件的这个模板吧，在这里，我们发现：\r\n\r\n1.父组件不知道子组件究竟做了什么（increment事件触发前的处理），同时也无需关心\r\n\r\n2.父组件只要完成它的任务：在increment事件触发的时候执行对应的函数就足够了\r\n\r\n对子组件反是\r\n\r\n \r\n\r\n所以，从这个角度上说，自定义事件使得父子组件“权责明确”\r\n\r\n \r\n\r\n【注意】官方文档的示例可能容易制造这样一种错觉：自定义事件是以原生事件（如click）为基础的,但实际上并不是这样。\r\n\r\n虽然自定义事件和原生事件息息相关，但自定义事件并不以原生事件的触发为基础的\r\n\r\n \r\n\r\n回到顶部\r\nSlot的使用\r\n当你试图使用slot的时候，你可能试图做这样一件事情：\r\n\r\n用父组件动态地控制子组件的显示的内容\r\n\r\n复制代码\r\nVue.component(\'son-component\', {\r\n  template: \'<div><slot></slot></div>\'\r\n})\r\n\r\nnew Vue({\r\n  el: \'#app\'\r\n})\r\n复制代码\r\n模板HTML：\r\n\r\n复制代码\r\n<div id=\'app\'>\r\n      <p>这是slot的内容</p>\r\n      <son-component>\r\n        <p>你好，我是slot</p>\r\n      </son-component>\r\n</div>\r\n复制代码\r\n \r\n\r\ndemo：\r\n\r\n \r\n\r\n【写给react的同学看的】你可以把slot看作是个3.0版本的props.children\r\n\r\n \r\n\r\n通俗的理解：\r\n\r\n在父组件模板中使用子组件的时候，如果在子组件里面嵌套了HTML的内容，它会以”props“的方式传递给子组件的模板，并被子组件中的slot接受，例如：\r\n\r\n \r\n\r\n【一个不太专业的说法】\r\n\r\n<son-component>\r\n   <p>你好，我是slot</p>\r\n</son-component>\r\n等同于\r\n\r\n<son-component  slot = \'<p>你好，我是slot</p>\'></son-component>\r\n \r\n\r\n具名slot\r\n为了使增强slot的用法，使父组件能够更加灵活地控制子组件，Vue引入了具名slot\r\n\r\n通过name属性，可以把在父组件中控制子组件同时渲染不同的slot\r\n\r\n复制代码\r\nVue.component(\'son-component\', {\r\n  template: \'<div><slot name=\"h1\"></slot><slot name=\"button\"></slot><slot name=\"a\"></slot></div>\'\r\n})\r\n\r\nnew Vue({\r\n  el: \'#app\'\r\n})\r\n复制代码\r\n \r\n\r\nHTML模板部分：\r\n\r\n复制代码\r\n<div id=\'app\'>\r\n\r\n      <son-component>\r\n\r\n        <h1 slot=\'h1\' >我是标题</h1>\r\n\r\n        <button slot=\'button\'>我是按钮</button>\r\n\r\n        <a href=\'#\' slot=\'a\'>我是链接</a>\r\n\r\n      </son-component>\r\n\r\n </div>\r\n复制代码\r\n demo:\r\n\r\n \r\n\r\n【注意事项】\r\n\r\n1.实际上，我觉得我这篇文章的语言有些过于罗嗦（其实很为难，因为说多了怕罗嗦——”太长不看“），说少了又怕不能完整地表达自己的意思，这是我权衡后的所做的结果\r\n\r\n2.文中很多只为知识点服务，跟实际的项目构建存在很大差异，例如我把很多模板都放在template选项中，而实际上我们会使用Vue单文件组件来实现这些\r\n\r\n【完】', 1, 1, 1, '2024-10-27 15:32:05', '2024-10-27 15:32:05', 0);
INSERT INTO `news_headline` VALUES (3, 'React开发入门', '一、前言\r\n近段时间看到学长公司招聘React Native工程师，当时比较好奇，就搜索了一下，然后刚好需要每个月买一本书看看，所以就买了一本《Reactive Native 开发指南》。\r\n但是看到里面的预备知识的时候，发现首先最好需要先了解一下React（书中写道：我们假设你对React已经有了一些了解），心想是不是还要买一本React的书籍，后来想想干脆直接从网上搜搜教程吧，因此开始去探索，最终找到了三个链接的内容讲的React还不错，一个是阮一峰的博客，一个是官方文档，一个是React概览。阮一峰的博客和React概览都是中文的，而且写的比较容易理解，而官方文档是英文的，讲解的都比较详细。所以如果自己英文好的话可以直接看官方文档。\r\n \r\n二、什么是React\r\nReact是一个JavaScript库，是由FaceBook和Instagram开发的，主要用于用户创建图形化界面。\r\n \r\n三、开发环境的搭建\r\n做任何开发环境，我都会想着首先需要搭建一个环境来开发。就像如果开发iOS，你需要有苹果电脑，然后从AppStore下载Xcode，然后就可以熟悉一个Xcode，看看文档，就可以开始开发了；就像如果开发Android，你需要安装Android Studio，然后需要安装Java环境，然后就可以进行开发了。对于React，经过了解，我发现任何一个工具，比如Sublime Text，IntelliJ IDEA等等都可以，你甚至直接可以使用文本编辑器等等。这里面我使用的是IntelliJ IDEA。\r\n          1、安装一个IntellJ IDEA就可以进行开发了。\r\n          2、一个浏览器（这里面我使用的是Chrome）\r\n          3、下载相关库（下载链接）\r\n \r\n四、预备知识\r\n这个博客主要是介绍的React，我也假设一下：你需要对HTML，CSS，JavaScript有一定的了解，因为代码大部分都是用这些来进行开发的。\r\n \r\n五、最简单的React小程序\r\n我学任何语言的时候第一个程序都是一个Hello,World!。现在就让我们来利用React来写一个最简单的Hello,World!\r\n直接上代码：\r\n \r\n复制代码\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n   <meta charset=\"utf-8\">\r\n   <title>Hello world!</title>\r\n   <script src = \"../../build/react.js\"></script>\r\n   <script src = \"../../build/react-dom.js\"></script>\r\n   <script src = \"../../build/browser.min.js\"></script>\r\n</head>\r\n<body>\r\n   <div id = \"example\"></div>\r\n   <script type=\"text/babel\">\r\n      ReactDOM.render(\r\n            <h1>Hello,World!</h1>,\r\n            document.getElementById(\'example\')\r\n      );\r\n   </script>\r\n</body>\r\n</html>\r\n复制代码\r\n然后用浏览器打开就可以了（这里假设你已经会使用IntellJ IDEA，如果不会就先使用Sublime Text），然后在浏览器里面就可以看到你特别熟悉的Hello,World！了。\r\n简单分析一下这个程序，首先，head里面引入了三个js文件。前两个是react的js文件，你可以在目录三里面的下载相关库里面拿。还有一个是browser.min.js，为什么要引入这个js可以参考这个提问，其实是为了将JSX语法转换成JavaScript语法。可以百度谷歌一下，下载该文件，也可以直接引用网上资源。然后就在html里面写了一个script代码块：\r\n<script type=\"text/babel\">\r\n   ReactDOM.render(\r\n         <h1>Hello,World!</h1>,\r\n         document.getElementById(\'example\')\r\n   );\r\n</script> \r\n这里需要注意：首先，/h1>后面是此外，以前我们可能使用的是type是text/javascript，现在我们使用的text/babel。这是因为React独有的JSX语法，跟JavaScript不兼容，凡是使用JSX的地方，都要加上type = “text/babel”。\r\n是不是已经开放蒙圈了，刚才提了好几个JSX，什么是JSX呢？React官方文档里面的解释是：XML语法内部包含JavaScript被叫做JSX。但是我理解的应该是我们直接在JS里面嵌入了HTML，这个就是React提出的叫做JSX的语法吧。这样做的好处就是一个组件的开发过程中，HTML是必不可少的一部分，能够将HTML封装起来才是组件的完全体。JSX语法的产生，让前端实现组件化成为了可能。\r\nJSX的基本语法规则：遇到HTML标签(以<开头)，就用HTML规则解析；遇到代码块(以{开头)，就用JavaScript规则解析。\r\n在ReactDOM.render里面写了两行，他们的作用就是将h1标题插入example节点。\r\n你也可以直接新建一个js文件，然后将body里script里面的代码直接放到里面，我们可以命名为helloworld.js，然后在head里面导入即可。我比较倾向于这种做法，因为至少html文件不会看着太大，而且方便引入管理。如果其他html也需要改代码块，直接引入即可。  \r\n \r\n六、基础语法介绍\r\n1、ReactDOM.render( )\r\nReactDOM.render是React最基本的语法，用于将模板转换成HTML语言，并插入指定的DOM节点。\r\nReactDOM.render(\r\n    <h1>Hello,World!</h1>,\r\n    document.getElementById(\'example\')\r\n);\r\n运行结果如下：\r\n\r\n2、map（遍历）\r\n将数组中的元素遍历赋值\r\n \r\n复制代码\r\nvar animals = [\'dog\',\'cat\',\'pig\'];\r\nReactDOM.render(\r\n    <div>\r\n        {\r\n            animals.map(function(animal) {\r\n              return <h1>{animal}</h1>\r\n            })\r\n        }\r\n    </div>,\r\n    document.getElementById(\'example\')\r\n);\r\n复制代码\r\n从这里开始都是讲React代码放到了.js文件里面，然后在html文件里面引入。引入的时候记得写type = ’text/babel’。这里会有一个小问题：打开浏览器的调试工具后，里面会看到Warning如下：\r\nWarning: Each child in an array or iterator should have a unique \"key\" prop. Check the top-level render call using <div>\r\n解决方法如下：\r\n复制代码\r\nvar animals = [\'dog\',\'cat\',\'pig\'];\r\nReactDOM.render(\r\n    <div>\r\n        {\r\n            animals.map(function(animal,key) {\r\n              return <h1 key = {key}>{animal}</h1>\r\n            })\r\n        }\r\n    </div>,\r\n    document.getElementById(\'example\')\r\n);\r\n复制代码\r\n警告的意思是最好给循环产生的child添加一个key。这样就可以接触警告了。运行结果如下：\r\n\r\n这里面你也许还会遇到另外一个问题，那就是用的Sublime Text，然后太浏览器打开的时候提示：\r\n \r\nbrowser.min.js:3 XMLHttpRequest cannot load file:///Users/**/***/React/MyReactDemo/helloworld/src/helloworld.js.\r\n Cross origin requests are only supported for protocol schemes: \r\nhttp, data, chrome, chrome-extension, https, chrome-extension-resource.\r\n 其实是因为我们将js单独拉出来文件导致的，但是你会发现如果使用Safari浏览器是没有这个问题的。在这里找到了答案：\r\n复制代码\r\nstartup chrome with --disable-web-security\r\nOn Windows:\r\n\r\nchrome.exe --disable-web-security\r\n\r\nOn Mac:\r\n\r\nopen /Applications/Google\\ Chrome.app/ --args --disable-web-security\r\n复制代码\r\n因为Chrome浏览器不支持本地ajax访问。\r\n你也可以构建本地服务器进行访问，比如我使用的intellJ IDEA ，直接就是在本地构建了一个本地服务，此时访问地址为：\r\nhttp://localhost:63342/MyReactDemo/helloworld/src/helloworld.html\r\n而没有构建本地服务的时候访问地址为：\r\nfile:///Users/zhanggui/zhanggui/React/MyReactDemo/helloworld/src/helloworld.html\r\n3、组件化\r\n\r\n因为React使用的是JSX，所以它允许将代码封装成组件（component），然后像普通的HTML标签一样插入。\r\n复制代码\r\nReact.createClass方法就是用于生成一个组件类，比如：\r\nvar ZGButton = React.createClass({\r\n    render:function() {\r\n        return <button>ZG{this.props.name}</button>\r\n    }\r\n});\r\nReactDOM.render(\r\n    <ZGButton name = \'Button1\'/>,\r\n    document.getElementById(\'example\')\r\n);\r\n \r\n复制代码\r\n运行结果如下：\r\n\r\n上面的ZGButton就是一个组件类，模板插入<ZGButton />，会自动生成一个该组件的实例。\r\n所有组件类都必须有自己的render方法，用于输出组件。\r\n现在代码这样写：\r\n复制代码\r\nvar zGButton = React.createClass({\r\n    render:function() {\r\n        return <button>ZG{this.props.name}</button>\r\n    }\r\n});\r\nReactDOM.render(\r\n    <zGButton name=\"Button2\">Button</zGButton>,\r\n    document.getElementById(\'example\')\r\n);\r\n复制代码\r\n也就是将组件类的第一个字符小写，然后在引用的时候发现现在是双标签了（代码自动填充的时候出现），而且name失效。因此我们在开发组件的时候一定要将第一个首字符大写，否则将不会达到你想要的效果。\r\n4、this.props.children\r\nthis.props对象的属性和组件的属性一一对应，但是有个children除外，它表示的是组件的所有子节点：\r\n \r\n复制代码\r\nvar Students = React.createClass({\r\n    render:function() {\r\n        return (\r\n            <ol>\r\n                {\r\n                    React.Children.map(this.props.children,function(child) {\r\n                        return <li>{child}</li>\r\n                    })\r\n                }\r\n            </ol>\r\n        );\r\n    }\r\n});\r\nReactDOM.render(\r\n    <Students>\r\n        <span>zhangsan</span>\r\n        <span>lisi</span>\r\n    </Students>,\r\n    document.getElementById(\'example\')\r\n);\r\n复制代码\r\n此时输出的结果为：\r\n\r\n5、PropTypes\r\n组件就类似与我们OC开发或者Java开发中的类，类可以进行属性添加，组件也可以。\r\n组件的属性可以接受任意值，字符串、对象、函数都行。这里面有一个propTypes，可以用来限定提供的属性是否满足要求：\r\n \r\n复制代码\r\nvar Student = React.createClass({\r\n    propTypes: {\r\n      myName:React.PropTypes.string.isRequired,\r\n    },\r\n    render:function() {\r\n        return <h1>\r\n            {this.props.myName}\r\n        </h1>\r\n    }\r\n});\r\nvar myNameStr = \"React\";\r\nReactDOM.render(\r\n    <Student myName = {myNameStr} />,\r\n    document.getElementById(\'example\')\r\n);\r\n复制代码\r\n这里面的propTypes里面的是对属性的限制，比如这里必须是string类型，值是必须的。我们还可以去设置默认属性值：\r\n \r\n复制代码\r\nvar Student = React.createClass({\r\n    getDefaultProps: function() {\r\n        return {\r\n            myName:\"Default React\"\r\n        }\r\n    },\r\n\r\n    propTypes: {\r\n      myName:React.PropTypes.string.isRequired,\r\n    },\r\n    render:function() {\r\n        return <h1>\r\n            {this.props.myName}\r\n        </h1>\r\n    }\r\n});\r\n复制代码\r\n这里面的getDefaultProps就类似与我们在开发iOS或者Java的时候对声明属性的时候进行赋初始化值。\r\n6、Virtual DOM\r\n组件并不是真实的DOM节点，而是存在于内存中的一种数据结构，叫做虚拟DOM，只有插入文档的时候才会变成真实的DOM。根据React的设计，当重新渲染组件的时候，会通多diff寻找到变更的DOM节点，再把这个修改更新到浏览器实际的DOM节点上，所以实际上并不是渲染整个DOM数，这个Virtual DOM是一个纯粹的JS数据结构，性能比原生DOM快很多。这里面我们可以用通过ref属性来获取真实的DOM属性：\r\n复制代码\r\nvar MyComponment = React.createClass({\r\n    render:function(){\r\n        return (\r\n          <div>\r\n              <input type = \"text\" ref = \"myTextInput\"/>\r\n              <input type = \"button\" value = \"Focus the text input\" onClick={this.handleClick}/>\r\n          </div>\r\n        );\r\n    },\r\n    handleClick:function() {\r\n        // alert(this.refs.myTextInput);\r\n        this.refs.myTextInput.focus();\r\n    }\r\n});\r\nReactDOM.render(\r\n    <MyComponment/>,\r\n    document.getElementById(\'example\')\r\n);\r\n复制代码\r\n这里需要注意的是，因为我们使用的是真实的DOM对象，所以一定要确保DOM插入文档之后才能够使用。\r\n7、this.state\r\n我们可以通过this.state来拿到组件的状态：\r\n复制代码\r\nvar LinkButton = React.createClass({\r\n    getInitialState:function () {\r\n      return {linked:false};\r\n    },\r\n    handleClick:function() {\r\n        this.setState({linked:!this.state.linked});\r\n    },\r\n    render:function() {\r\n        var text = this.state.linked? \'linked\':\'not linked\';\r\n        return (\r\n            <p onClick={this.handleClick}>\r\n                You {text} this. Click to toggle\r\n            </p>\r\n        );\r\n    }\r\n});\r\nReactDOM.render(\r\n    <LinkButton/>,\r\n    document.getElementById(\'example\')\r\n);\r\n复制代码\r\n这里面我设置了一个linked的状态（是否连接）,这里通过this.state拿到当前状态，通过this.setState来设置状态。\r\n8、表单\r\n表单填写是用户和组件的互动：\r\n \r\n复制代码\r\nvar Form = React.createClass({\r\n    getInitialState:function() {\r\n        return {value:\'Hello\'};\r\n       \r\n    },\r\n    handleChange:function(event) {\r\n        this.setState({value:event.target.value});\r\n    },\r\n    render:function() {\r\n        var value = this.state.value;\r\n        return (\r\n            <div>\r\n                <input type=\"text\" value = {value} onChange={this.handleChange}/>\r\n                <p>{value}</p>\r\n            </div>\r\n\r\n        );\r\n    }\r\n});\r\nReactDOM.render(\r\n    <Form/>,\r\n    document.getElementById(\'example\')\r\n);', 1, 1, 1, '2024-10-27 15:32:05', '2024-10-27 15:32:05', 0);
INSERT INTO `news_headline` VALUES (7, '类加载子系统（类加载器、双亲委派）', '类加载系统加载类时分为三个步骤，加载、链接、初始化，下面展开介绍。\r\n\r\n类加载子系统结构图：\r\n\r\n\r\n1 类加载器\r\nJVM 使用类加载器加载 class 文件，类加载器可分为引导类加载器和自定义类加载器两种。\r\n\r\n引导类加载器（Bootstrap ClassLoader），有时也被称作启动类加载器或者零类加载器（Null ClassLoader），是 Java 虚拟机中最基础的类加载器之一。它的主要职责是加载 Java 核心类库。\r\n\r\n自定义类加载器需要继承自 ClassLoader 类，JDK 默认提供了一些。比较重要的有两个，拓展类加载器（ExtClassLoader） 和应用类加载器（AppClassLoader） 。\r\n\r\n下面展开说说这三个加载器的作用、区别以及联系。先看一张图：\r\n\r\n\r\n\r\n1.1 引导类加载器（BootStrapClassLoader）\r\n特点：\r\n\r\n内部实现：引导类加载器并不是通过 Java 代码实现的，而是用 C++ 或者其他本地语言编写的，并且是 JVM 的一部分。\r\n加载路径：引导类加载器通常从 $JAVA_HOME/jre/lib/ 或类似的位置加载 Java 核心类。\r\n无父类加载器：引导类加载器没有显式的父类加载器，这是因为它的设计目的是为了加载 Java 最基础的类库，而这些类库是任何其他类加载器工作的前提。因此，它不需要依赖于任何其他类加载器。\r\n不可见性：引导类加载器并不是对所有 Java 应用程序都可见的，因为它是 JVM 的一部分，而不是标准的 Java 类加载器层次结构的一部分。\r\n优先级：引导类加载器通常是整个类加载过程的第一步，当 Java 应用程序启动时，它会首先加载必要的核心类库，然后才允许后续的类加载器（如扩展类加载器和应用类加载器）开始工作。\r\n1.2 拓展类加载器（ExtClassLoader）\r\n特点：\r\n\r\n内部实现：ExtClassLoader是在sun.misc.Launcher类里的静态内部类，继承自 ClassLoader 类，重写 loadClass() 方法。\r\n加载路径：ExtClassLoader 主要负责加载位于 $JAVA_HOME/jre/lib/ext 目录下的扩展类库。\r\n委托模型：ExtClassLoader 遵循 Java 类加载器的委托模型。当它收到一个类加载请求时，它首先会尝试使用其父类加载器（即 Bootstrap ClassLoader）来加载这个类。如果父类加载器无法加载，则 ExtClassLoader 会尝试自己加载。\r\n优先级：ExtClassLoader 位于 BootstrapClassLoader 之后，但在 AppClassLoader之前。这意味着它继承了 Bootstrap ClassLoader 的特性，并且它加载的类对 Application ClassLoader 可见。\r\n1.3 应用类加载器（AppClassLoader）\r\n特点：\r\n\r\n内部实现：AppClassLoader也是在sun.misc.Launcher类里的静态内部类，继承自 ClassLoader 类，重写 loadClass() 方法。\r\n加载路径：AppClassLoader主要负责的目录是当前应用程序的 classpath 所指定的路径，也就是说我们自己写的类默认都是通过AppClassLoader加载的。我们在IDEA里运行代码时，仔细观察控制台可以发现第一行通过-classpath指定了当前应用程序的class文件的目录\r\n委托模型：AppClassLoader 遵循 Java 类加载器的委托模型。当它收到一个类加载请求时，它首先会尝试使用其父类加载器 ExtClassLoader来加载这个类。如果父类加载器无法加载，则 AppClassLoader 会尝试自己加载。\r\n优先级：AppClassLoader位于ExtClassLoader 之后。\r\n除了这些特点外，AppClassLoader还有一些别的用途：\r\n\r\n加载第三方 Jar 包：当应用程序依赖于第三方库时，这些库通常会被打包成 JAR 包，并放置在类路径中。AppClassLoader 会加载这些 JAR 包中的类。\r\n动态加载类：在一些需要动态加载类的场景中，如 Spring Boot 应用程序，AppClassLoader 可以用于动态加载和卸载类。\r\n1.4 双亲委派\r\n原因一：前面我们介绍了引导类加载器、拓展类加载器、应用类加载器分别负责不同的路径下的class文件，但是并不是完全不相交的，比如-classpath除了指定当前应用程序的class文件目录外，也会指定$JAVA_HOME/jre/lib/目录下的某些 jar 包，所以要避免重复加载某些类。\r\n\r\n原因二：如果我们的程序被黑客攻击了，比如黑客自己创建了一个java.lang的包，里面创建了一个名为String的类，把这个包和类植入我们正在运行的项目里，如果他的这个类被加载了，那我们项目里的String就会被篡改。\r\n\r\n为了避免以上两种原因，我们要保证类只加载一次，并且保证越靠近 JVM 的类加载器优先级越高。这就是双亲委派干的事情！！！\r\n\r\n原理：\r\n\r\n引导类加载器、拓展类加载器、应用类加载器这三者之前有个关系，但又不是父子类关系，而是应用类加载器有个parent属性是拓展类加载器的对象。拓展类加载器的parent为空，所以会调用引导类加载器。我们观察ClassLoader的loaderClass()方法可以得出类的加载过程：\r\n\r\nloadClass()方法\r\n\r\n双亲委派机制\r\n\r\n简单来说就是，\r\n\r\n通过AppClassLoader加载class时会先用ExtClassLoader去加载这个类；\r\n\r\n通过ExtClassLoader加载class时会先用BootStrapClassLoader去加载这个类；\r\n\r\n好处：\r\n\r\n避免类被重复加载。\r\n防止JVM核心类被篡改。\r\n2 链接\r\nclass 加载完后会进行链接，分为三步：验证、准备、解析。\r\n\r\n2.1 验证\r\n第一步是验证 class 文件是否正确，比如验证格式。\r\n\r\n2.2 准备\r\n对 static 修饰的属性赋予一个默认值，但这一步不会赋初始值。\r\n\r\n举个例子，class 里定义了一个static int a = 1，准备阶段会把 a 赋值为 0，在初始化阶段 a 才会 = 1。\r\n\r\n2.3 解析\r\n将符号引用解析为直接引用。什么意思呢？\r\n\r\n首先我们需要知道类被加载后是放到方法区的，每个类都是一个 Klass 对象（也可称为 Klass 结构）。\r\n\r\n一般情况下我们都会在一个A类里使用到别的B类，使用方式是B类的全限定名，就只是一个字符串。但是JVM 实际在执行的时候需要从方法区中找到B类的 Klass 对象，解析的作用就是把这个名称字符串替换为实际的 Klass 对象内存地址。“符号引用”就是名称字符串、“直接引用”就是 Klass 对象内存地址。\r\n\r\n3 初始化\r\n初始化是类加载子系统的最后一个阶段，也是最为关键的阶段之一。下面详细介绍初始化阶段的内容及其重要性。\r\n\r\n3.1 定义\r\n初始化阶段是类加载过程中的最后一个阶段，它负责执行类构造器 <clinit> 方法，并初始化类的静态变量。\r\n\r\n3.2 主要任务\r\n初始化阶段的主要任务包括：\r\n\r\n执行类构造器 <clinit> 方法：<clinit> 方法是一个特殊的静态构造器，它负责对类进行初始化。每个类都有一个 <clinit> 方法，该方法在类第一次被初始化时由 JVM 自动生成并执行。\r\n初始化类变量：类中的静态变量（即类变量）在 <clinit> 方法中被赋值。\r\n3.3 <clinit> 方法的特点\r\n静态块：在类定义中，静态代码块会被编译器转化为 <clinit> 方法中的语句。\r\n顺序执行：如果一个类有多个静态代码块，它们将按照在源代码中出现的顺序依次执行。\r\n线程安全：<clinit> 方法是线程安全的，这意味着即使有多个线程同时初始化同一个类，也不会发生冲突。\r\n3.4 示例代码\r\n下面是一个简单的示例，展示类的初始化过程：\r\n\r\n    public class InitializationExample {\r\n        static {\r\n            System.out.println(\"执行静态初始化块。\");\r\n        }\r\n\r\n        static int staticVar = initializeStaticVar();\r\n\r\n        private static int initializeStaticVar() {\r\n            System.out.println(\"初始化静态变量。\");\r\n            return 10;\r\n        }\r\n\r\n        public static void main(String[] args) {\r\n            System.out.println(\"静态变量初始化为: \" + staticVar);\r\n        }\r\n    }\r\n输出如下：\r\n\r\n    执行静态初始化块。\r\n    初始化静态变量。\r\n    静态变量初始化为: 10\r\n3.5 初始化时机\r\n类的初始化通常在以下几种情况下触发：\r\n\r\n首次创建类的实例：当第一次创建类的实例时，JVM 会初始化该类。\r\n调用类的静态方法：当第一次调用类的静态方法时，JVM 会初始化该类。\r\n引用类的静态字段：当第一次引用类的静态字段时，JVM 会初始化该类。\r\n反射性引用：当通过 java.lang.Class 或 java.lang.reflect 包中的方法来引用类时，如果这些方法会导致类的初始化，那么 JVM 会初始化该类。\r\n初始化子类时：当初始化一个类的子类时，如果父类还没有被初始化，那么 JVM 会首先初始化父类。\r\n3.6 初始化顺序\r\n类的初始化顺序遵循一定的规则：\r\n\r\n如果类 A 引用了类 B 的静态字段或调用了类 B 的静态方法，那么类 B 必须先于类 A 被初始化。\r\n如果类 A 继承自类 B，那么类 B 必须先于类 A 被初始化。', 2, 2, 0, '2024-10-27 15:32:05', '2024-10-27 15:32:05', 0);
INSERT INTO `news_headline` VALUES (8, '全中国有多少公网IP地址？', '之前为了准备CTF比赛，搞了一个云服务器，顺便申请了一个公网IP。\r\n\r\n看着申请到的IP地址，我突然想到了一个问题：不是早就说IP地址已经耗尽了吗，为什么我随便就能申请到，是谁在负责IP地址的管理分配，咱们中国总共又有多少IP地址呢？\r\n\r\n答案：大概是3.9亿多个。而美国有十多亿，是我们的好几倍。这个数字怎么来的呢，别着急，继续往下看。\r\n\r\n \r\n\r\n大家知道，我们现在的互联网主要还是采用的IPv4的地址，虽然我上大学那会儿就在吼IPv6了，但这么多年过去了，IPv4的地位依旧没有动摇。\r\n\r\nIPv4的IP地址，是采用4个字节的整数来表示，学过编程的都知道，4个字节能够表示的范围是0-4294967295（无符号数）。\r\n\r\n也就是说，全世界最多只有42.9亿个IPv4的地址。\r\n\r\n当然，为了书写和记忆方便，我们一般不会用整数来表示，而是采用点分十进制的形式。\r\n\r\n从 0.0.0.0 到255.255.255.255，分四个字节，每个字节范围是0-255。\r\n\r\n然而，IP地址中不是所有都能拿来直接用，这42.9亿中有不少特殊用途的IP地址。\r\n\r\n比如很多人都知道这三个范围的私有IP：\r\n\r\n10.0.0.0--10.255.255.255\r\n172.16.0.0--172.31.255.255\r\n192.168.0.0--192.168.255.255\r\n实际上，除了这三个范围的IP地址，还有许多特殊用途的IP地址。网络上很多文章列举的七七八八，都不完善，完整的特殊IP地址列表，还得要去管理IP地址的IANA官网查看。\r\n\r\nIANA\r\nIANA，全称Internet Assigned Numbers Authority，互联网号码分配机构，它管理着全球互联网中使用的IP地址、域名和许多其它参数。\r\n\r\n\r\n\r\n在它的官网中，有一个文档，包含了迄今为止，所有特殊用途的IP地址：\r\n\r\n地址：https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml\r\n\r\n\r\n很多人都知道127.0.0.1代表着本地回环地址，但其实回环地址不只是一个，从127.0.0.0-127.255.255.255整个16777216个地址都是回环地址，所有发往这些地址的数据包都会被loop back。\r\n\r\nIP地址本就珍贵，这么多都作为回环地址，是不是有点浪费啊？\r\n\r\n \r\n\r\n中国的IPv4地址数量\r\n全球的IP地址由五大区域性机构进行管理，咱们国家的IP地址由亚太地区的APNIC分配管理。\r\n\r\n\r\n\r\n在APNIC的官网上，也有一个公开的文档，记录了APNIC管理分配的所有IP地址信息，每日更新，可以访问下面这个地址拿到：\r\n\r\nhttp://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest\r\n\r\n\r\n该文件每行的格式如下：\r\n\r\n注册机构|国家/地区代码|类型|起始地址|IP数量|分配日期|状态\r\n咱们大陆地区的代码是CN，所以，可以通过简单的命令将大陆地区的IPv4地址分配情况筛选出来：\r\n\r\ncat delegated-apnic-latest | grep \"CN|ipv4\" > cn_ipv4.txt\r\n可以看到，截止2024-8-17日，中国大陆地区一共分配了8655个网段：\r\n\r\n\r\n\r\n写个简单的脚本程序，将所有网段的IP地址数量相加:\r\n\r\nimport sys\r\ntotal = 0\r\nprint(\'target file: %s\' % sys.argv[1])\r\nwith open(sys.argv[1]) as fp:\r\n    while True:\r\n      line = fp.readline()\r\n      if line:\r\n          fields = line.split(\'|\')\r\n          ip = fields[3]\r\n          num = int(fields[4])\r\n          print(\'ip: %s, num: %d\' % (ip, num))\r\n          total += num\r\n      else:\r\n          break\r\nprint(\'total: %d\' % total)\r\n得到总共的IP地址数量：3 4314 4448，约占整个IP地址空间的8%。\r\n\r\n用同样的方法，分别统计台湾、香港、澳门三个地区的数据：\r\n\r\n台湾：35711232\r\n香港：12571136\r\n澳门：337664\r\n那整个加起来的数据就是：3 9176 4480，三亿九千多万，约占整个IP地址空间的9.14%。\r\n\r\n通过同样的方法，还可以找到美国的数据，大概是15 8647 9872，接近16亿左右。按照人均来算，美国人均可以分到4个公网IP地址。真是太阔绰了，没办法，谁让互联网是人家发明的呢。\r\n\r\n \r\n\r\n那这个数据到底对不对呢？\r\n\r\n我查阅了国内专门负责IP地址分配管理的机构：CNNIC（中国互联网络信息中心）在今年3月份发布的一份《第 53 次中国互联网络发展状况 统计报告》，其中关于IP地址这里，有一个数据：\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n这份文件给出去年12月份的数据，全国的IPv4地址大概在3.92亿，与前面的统计基本上吻合，可能由于数据时间和其他方面的因素，存在小部分的出入，但总体而言，国内的IPv4地址数量大概在这个规模是肯定的。\r\n\r\n \r\n\r\n阿里云的IPv4地址数量\r\n弄清了国内的IP地址数量，那么问题来了，阿里云到底有多少IPv4地址呢？\r\n\r\n在淘宝下的一个IP地址库中找到了一个数据：\r\n\r\n地址：https://ip.taobao.com/accurancy\r\n\r\n\r\n当然，从表格中大陆地区的IP地址数量可以看到，这个表格的数据是有些过时了，但数量级应该差不了太多。\r\n\r\n从这份数据来看，阿里巴巴拥有差不多 370W+ 的IP地址。\r\n\r\n而这，仅仅是活跃的IP地址数，不代表阿里所屯的IP地址总数。\r\n\r\n那阿里究竟屯了多少IP，在公开的信息中，我只找到了一份2019年发布的数据：\r\n\r\n\r\n\r\n2019上半年，阿里云的活跃IP数量在330万，比上面的淘宝IP统计少了40万，也就是说2年之后活跃IP增长了40万。\r\n\r\n而光是2019年的这份数据，阿里云屯的IP总数已经超过1500W+，而现在，这个数据只会更多，就国内几家云服务厂商而言，可谓是一骑绝尘了。\r\n\r\n从上面图中还可以看出，亚马逊不愧是全球最强大的云计算厂商，足足屯了7500W+ 的IP地址，就这还是几年前数据。\r\n\r\n \r\n\r\n至此，我们的问题算是弄清楚了。当然了，购买云服务器得来的IP地址也是有租用期限的，云服务器到期之后，里面的公网IP地址也就回收了。\r\n\r\n虽然IP地址紧张，但各云服务器厂商都屯了不少，公网IP在池子里不断流转，所以我们才能花个百来十块就搞来一个。\r\n\r\n \r\n\r\n最后，给大家留一个思考题：0.0.0.0和127.0.0.1这两个IP地址，有什么不同？\r\n\r\n \r\n\r\n很多小伙伴有查询IP地址归属地的需求，这里推荐一个纯真数据库：\r\n\r\n纯真(CZ88.NET)自2005年起一直为广大社区用户提供社区版IP地址库，只要获得纯真的授权就能免费使用，并不断获取后续更新的版本。如果有需要免费版IP库的朋友可以前往纯真的官网进行申请。\r\n纯真除了免费的社区版IP库外，还提供数据更加准确、服务更加周全的商业版IP地址查询数据。纯真围绕IP地址，基于 网络空间拓扑测绘 + 移动位置大数据 方案，对IP地址定位、IP网络风险、IP使用场景、IP网络类型、秒拨侦测、VPN侦测、代理侦测、爬虫侦测、真人度等均有近20年丰富的数据沉淀。', 2, 2, 0, '2024-10-27 15:32:05', '2024-10-27 15:32:05', 0);
INSERT INTO `news_headline` VALUES (9, 'ACM数学（转）', '从放暑假前周sir给我讲了一个用polya计数法和burnside定理做的题目（pku2409）后，突然觉得组合数学挺有意思，然后从那时起到现在几乎都在做这类的题目。  \r\n做到现在感觉这类题目的一些基本知识点都差不多有所了解了，水题也刷了不少，但还有很多难题自己实在是做不动，所以准备把这类题目先放一放，然后把前段时间做的水题整理一下（供以后的初学者参考，大牛就不要看了哈，都是水题）。剩下的比较难的题目就慢慢来吧，以后做出来再不上，这个小结会不断地更新。也希望大家有好的题目可以推荐一下，分享一下哈。  \r\n     感谢：周sir，J_factory和福州大学神牛aekdycoin，大连理工大学神牛czyuan。  \r\n不扯了，进入主题：  \r\n    1.burnside定理，polya计数法  \r\n这个专题我单独写了个小结，大家可以简单参考一下：polya 计数法，burnside定理小结  \r\n    2.置换，置换的运算  \r\n    置换的概念还是比较好理解的，《组合数学》里面有讲。对于置换的幂运算大家可以参考一下潘震皓的那篇《置换群快速幂运算研究与探讨》，写的很好。  \r\n*简单题：（应该理解概念就可以了）  \r\npku3270 Cow Sorting   \r\nhttp://acm.pku.edu.cn/JudgeOnline/problem?id=3270  \r\n    pku1026 Cipher  \r\nhttp://acm.pku.edu.cn/JudgeOnline/problem?id=1026  \r\n    *置换幂运算：  \r\npku1721 CARDS  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=1721  \r\n    pku3128 Leonardo\'s Notebook  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=3128  \r\n    *推荐：（不错的应用）  \r\npku3590 The shuffle Problem  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=3590  \r\n    3.素数，整数分解，欧拉函数  \r\n素数是可能数论里最永恒，最经典的问题了（我们的队名就叫PrimeMusic^-^）。素数的判断，筛法求素数，大素数的判断···还有很多其他问题都会用到素数。  \r\n*最水最水的：（心情不爽时用来解闷吧）  \r\npku1365 Prime Land  \r\npku2034 Anti-prime Sequences  \r\npku2739 Sum of Consecutive Prime Numbers  \r\npku3518 Prime Gap  \r\npku3126 Prime Path  \r\npku1595 Prime Cuts  \r\npku3641 Pseudoprime numbers  \r\npku2191 Mersenne Composite Numbers  \r\npku1730 Perfect Pth Powers  \r\npku2262 Goldbach\'s Conjecture  \r\npku2909 Goldbach\'s Conjecture  \r\n*筛法：  \r\npku2689 Prime Distance（很好的一个应用）  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=2689  \r\n    *反素数：  \r\nzoj2562 More Divisors  \r\nhttp://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2562  \r\n    *素数判断，整数分解：  \r\n这两题都要用到miller_rabin的素数判断和pollard_rho的整数分解，算法书上都会有，应该是属于模板题吧，不过最好看懂自己敲一遍。  \r\npku1811 Prime Test  \r\nhttp://acm.pku.edu.cn/JudgeOnline/problem?id=1811  \r\n    pku2429 GCD & LCM Inverse  \r\nhttp://acm.pku.edu.cn/JudgeOnline/problem?id=2429  \r\n    *欧拉函数：  \r\n数论里很多地方都能用到欧拉函数，很重要的。  \r\npku1284 Primitive Roots （很水）  \r\nhttp://acm.pku.edu.cn/JudgeOnline/problem?id=1284  \r\n    pku2407 Relatives （很水）  \r\nhttp://acm.pku.edu.cn/JudgeOnline/problem?id=2407  \r\n    pku2773 Happy 2006  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=2773  \r\n    pku2478 Farey Sequence （快速求欧拉函数）  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=2478  \r\n    pku3090 Visible Lattice Points （法雷级数）  \r\nhttp://acm.pku.edu.cn/JudgeOnline/problem?id=3090  \r\n    *推荐：（欧拉函数，费马小定理）  \r\npku3358 Period of an Infinite Binary Expansion  \r\nhttp://acm.pku.edu.cn/JudgeOnline/problem?id=3358  \r\n    *整数分解  \r\n这个也很重要的耶，包括大数的表示方法。  \r\npku2992 Divisors  \r\nhttp://acm.pku.edu.cn/JudgeOnline/problem?id=2992  \r\n    fzu1753 Another Easy Problem   \r\nhttp://acm.fzu.edu.cn/problem.php?pid=1753  \r\n    hit2813 Garden visiting  \r\nhttp://acm-hit.sunner.cn/judge/show.php?Proid=2813  \r\n    pku3101 Astronomy （分数的最小公倍数）  \r\nhttp://acm.pku.edu.cn/JudgeOnline/problem?id=3101  \r\n    4.扩展欧几里得，线性同余，中国剩余定理  \r\n    这应该是数论里比较重要的一个部分吧，这类的题目也挺多，具体的内容最好先看看数论书，我也整理过一些，可以参考参考：  \r\nhttp://hi.baidu.com/%B1%BF%D0%A1%BA%A2%5Fshw/blog/item/0676025d56a87d4afbf2c093.html  \r\n    *简单题：  \r\npku1006 Biorhythms  \r\nhttp://acm.pku.edu.cn/JudgeOnline/problem?id=1006  \r\n    pku1061 青蛙的约会  \r\nhttp://acm.pku.edu.cn/JudgeOnline/problem?id=1061  \r\n    pku2891 Strange Way to Express Integers  \r\nhttp://acm.pku.edu.cn/JudgeOnline/problem?id=2891  \r\n    pku2115 C Looooops  \r\nhttp://acm.pku.edu.cn/JudgeOnline/problem?id=2115  \r\n    pku2142 The Balance  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=2142  \r\n    *强烈推荐：  \r\nsgu106 The equation   \r\nhttp://acm.sgu.ru/problem.php?contest=0&problem=106  \r\n    pku3708 Recurrent Function （经典）  \r\nhttp://acm.pku.edu.cn/JudgeOnline/problem?id=3708  \r\n    5.约瑟夫环问题  \r\n这个问题还是比较有意思的，不是很难。  \r\n*简单题：  \r\npku3517 And Then There Was One  \r\nhttp://acm.pku.edu.cn/JudgeOnline/problem?id=3517  \r\n    pku1781 In Danger  \r\nhttp://acm.pku.edu.cn/JudgeOnline/problem?id=1781  \r\n    pku1012 Joseph  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=1012  \r\n    pku2244 Eeny Meeny Moo  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=2244  \r\n    *推荐：  \r\npku2886 Who Gets the Most Candies?  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=2886  \r\n    6.高斯消元法解方程  \r\n其实解方程并不是很难，就是按线性代数中学的那种方法，把系数矩阵化成上三角矩阵或数量矩阵，不过有些题目要判断是否有解，或枚举所有解。不过这类题目我认为比较难的还是怎么去建立这个方程组，这个理解了，就没什么大问题了。  \r\n*简单题：  \r\npku1222 EXTENDED LIGHTS OUT  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=1222  \r\n    pku1681 Painter\'s Problem  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=1681  \r\n    pku1830 开关问题  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=1830  \r\n    *推荐：  \r\npku2947 Widget Factory  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=2947  \r\n    pku2065 SETI  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=2065  \r\n    *强烈推荐：  \r\npku1753 Flip Game  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=1753  \r\n    pku3185 The Water Bowls  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=3185  \r\n    *变态题：  \r\npku1487 Single-Player Games  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=1487     \r\n7.矩阵  \r\n用矩阵来解决问题确实很常见，但我现在用到还不是很好，很多难题我还不会做。建议大家可以去看Matrix67的那篇关于矩阵的十个问题，确实很经典，但不太好看懂。  \r\n*简单：  \r\npku3070 Fibonacci  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=3070  \r\n    pku3233 Matrix Power Series  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=3233  \r\n    pku3735 Training little cats  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=3735  \r\n    8.高次同余方程  \r\n有关这个问题我应该是没什么发言权了，A^B%C=D，我现在只会求D和B，唉，很想知道A该怎么求。就先推荐几道题目吧，这里涉及到了一个baby-step，giant-step算法。  \r\nfzu1759 Super A^B mod C  \r\nhttp://acm.fzu.edu.cn/problem.php?pid=1759  \r\n    pku3243 Clever Y  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=3243  \r\n    pku2417 Discrete Logging  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=2417  \r\n    hdu2815 Mod Tree  \r\nhttp://acm.hdu.edu.cn/showproblem.php?pid=2815  \r\n    9.容斥原理，鸽巢原理  \r\n    很有用的两个定理，但好像单独考这两个定理的不是很多。  \r\n*鸽巢原理：  \r\npku2365 Find a multiple  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=2356  \r\n    pku3370 Halloween treats  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=3370  \r\n    *容斥原理：  \r\nhdu1695 GCD  \r\nhttp://acm.hdu.edu.cn/showproblem.php?pid=1695  \r\n    hdu2461 Rectangles  \r\nhttp://acm.hdu.edu.cn/showproblem.php?pid=2461  \r\n    10.找规律，推公式  \r\n这类题目的设计一般都非常巧妙，真的是很难想出来，但只要找到规律或推出公式，就不是很难了。我很多都是在参考别人思路的情况下做的，能自己想出来真的很不容易。  \r\n*个人感觉都挺不错的：  \r\npku3372 Candy Distribution  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=3372  \r\n    pku3244 Difference between Triplets  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=3244  \r\n    pku1809 Regetni  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=1809  \r\n    pku1831 不定方程组  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=1831  \r\n    pku1737 Connected Graph  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=1737  \r\n    pku2480 Longge\'s problem  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=2480  \r\n    pku1792 Hexagonal Routes  \r\nhttp://acm.pku.edu.cn/JudgeOnline/problem?id=1792  \r\n    11.排列组合，区间计数，计数序列  \r\n这些题目可能需要一些组合数学知识，基本上高中的知识就够了。区间计数问题一般不难，但写的时候需要仔细一些，各种情况要考虑到位。至于像卡特兰数，差分序列，斯特灵数···都还挺有意思，可以去看看《组合数学》。  \r\n*简单题：  \r\npku1850 Code  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=1850  \r\n    pku1150 The Last Non-zero Digit  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=1150  \r\n    pku1715 Hexadecimal Numbers  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=1715  \r\n    pku2282 The Counting Problem  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=2282  \r\n    pku3286 How many 0\'s?  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=3286  \r\n    *推荐：  \r\npku3252 Round Numbers  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=3252  \r\n    *计数序列：  \r\npku1430 Binary Stirling Numbers  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=1430  \r\n    pku2515 Birthday Cake  \r\nhttp://acm.pku.edu.cn/JudgeOnline/problem?id=2515  \r\n    pku1707 Sum of powers  \r\nhttp://acm.pku.edu.cn/JudgeOnline/problem?id=1707  \r\n    12.二分法  \r\n二分的思想还是很重要的，这里就简单推荐几个纯粹的二分题。  \r\n*简单：  \r\npku3273 Monthly Expense  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=3273  \r\n    pku3258 River Hopscotch  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=3258  \r\n    pku1905 Expanding Rods  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=1905  \r\n    pku3122 Pie  \r\nhttp://162.105.81.212/JudgeOnline/problem?id=3122  \r\n    *推荐：  \r\npku1845 Sumdiv  \r\nhttp://acm.pku.edu.cn/JudgeOnline/problem?id=1845  \r\n    13.稳定婚姻问题  \r\n    无意中接触到这个算法，还蛮有意思的，《组合数学》中有详细的介绍。  \r\npku3487 The Stable Marriage Problem  \r\nhttp://acm.pku.edu.cn/JudgeOnline/problem?id=3487  \r\n    zoj1576 Marriage is Stable  \r\nhttp://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=1576  \r\n    14.数位类统计问题  \r\n    在航点月赛中第一次接触到这类问题，scau大牛little龙推荐我看了一篇论文，09年刘聪的《浅谈数位类统计问题》，这篇论文相当精彩，也相当详细，每道题都有详细的分析和作者的参考代码。所以我也没什么可说的了，这些题的代码我博客里也就不贴了，大家直接去看论文吧。  \r\n简单：  \r\nural1057 Amount of degrees  \r\nhttp://acm.timus.ru/problem.aspx?space=1&num=1057  \r\n    spoj1182 Sorted bit squence  \r\nhttps://www.spoj.pl/problems/SORTBIT/  \r\n    hdu3271 SNIBB  \r\nhttp://acm.hdu.edu.cn/showproblem.php?pid=3271  \r\n    较难：  \r\nspoj2319 Sequence  \r\nhttps://www.spoj.pl/problems/BIGSEQ/  \r\n    sgu390 Tickets  \r\nhttp://acm.sgu.ru/problem.php?contest=0&problem=390  \r\n      以上分类的题目在我的博客里都可以找到详细的解题报告和参考代码，由于比较麻烦就没加链接，需要的可以用我的站内搜索找到。  \r\n     本小结会不断更新，转载请注明出处。  \r\n     严重声明：本文只适合ACM初学者，路过的大牛如有相同类型的比较好的题目可以推荐一些啊。  \r\n来自: http://hi.baidu.com/%B1%BF%D0%A1%BA%A2%5Fshw/blog/item/5305e12c7289973e359bf768.html  ', 3, 2, 0, '2024-10-27 15:32:05', '2024-10-27 15:32:05', 0);
INSERT INTO `news_headline` VALUES (10, '卷积的物理意义', '卷积这个东东是“信号与系统”中论述系统对输入信号的响应而提出的。因为是对模拟信号论述的，所以常常带有繁琐的算术推倒，很简单的问题的本质常常就被一大堆公式淹没了，那么卷积究竟物理意义怎么样呢？\r\n\r\n卷积表示为y(n) = x(n)*h(n)\r\n\r\n使用离散数列来理解卷积会更形象一点，我们把y(n)的序列表示成y(0),y(1),y(2) and so on; 这是系统响应出来的信号。\r\n\r\n同理，x(n)的对应时刻的序列为x(0),x(1),x(2)...and so on;\r\n\r\n其实我们如果没有学过信号与系统，就常识来讲，系统的响应不仅与当前时刻系统的输入有关，也跟之前若干时刻的输入有关，因为我们可以理解为这是之前时刻的输入信号经过一种过程（这种过程可以是递减，削弱，或其他）对现在时刻系统输出的影响，那么显然，我们计算系统输出时就必须考虑现在时刻的信号输入的响应以及之前若干时刻信号输入的响应之“残留”影响的一个叠加效果。\r\n\r\n假设0时刻系统响应为y(0),若其在1时刻时，此种响应未改变，则1时刻的响应就变成了y(0)+y(1),叫序列的累加和（与序列的和不一样）。但常常系统中不是这样的，因为0时刻的响应不太可能在1时刻仍旧未变化，那么怎么表述这种变化呢，就通过h(t)这个响应函数与x(0)相乘来表述，表述为x(m)×h(m-n)，具体表达式不用多管，只要记着有大概这种关系，引入这个函数就能够表述y(0)在1时刻究竟削弱了多少，然后削弱后的值才是y(0)在1时刻的真实值，再通过累加和运算，才得到真实的系统响应。\r\n\r\n再拓展点，某时刻的系统响应往往不一定是由当前时刻和前一时刻这两个响应决定的，也可能是再加上前前时刻，前前前时刻，前前前前时刻，等等，那么怎么约束这个范围呢，就是通过对h(n)这个函数在表达式中变化后的h(m-n)中的m的范围来约束的。即说白了，就是当前时刻的系统响应与多少个之前时刻的响应的“残留影响”有关。\r\n\r\n当考虑这些因素后，就可以描述成一个系统响应了，而这些因素通过一个表达式（卷积）即描述出来不得不说是数学的巧妙和迷人之处了。\r\n\r\n \r\n\r\n \r\n\r\n对于非数学系学生来说，只要懂怎么用卷积就可以了，研究什么是卷积其实意义不大,它就是一种微元相乘累加的极限形式。卷积本身不过就是一种数学运算而已。就跟“蝶形运算”一样，怎么证明，这是数学系的人的工作。\r\n在信号与系统里，f(t)的零状态响应y(t)可用f(t)与其单位冲激响应h(t) 的卷积积分求解得，即y(t)=f(t)*h(t)。学过信号与系统的都应该知道，时域的卷积等于频域的乘积，即有 Y(s)=F(s)×H(s)。（s=jw，拉氏变换后等到的函数其实就是信号的频域表达式）\r\n有一点你必须明白，在通信系统里，我们关心的以及 要研究的是信号的频域，不是时域，原因是因为信号的频率是携带有信息的量。\r\n所以，我们需要的是Y(s)这个表达式，但是实际上，我们往往不能很容易的得到F(s)和H(s)这两个表达式，但是能直接的很容易的得到f(t)和h(t)，所以为了找到Y(s)和y(t)的对应关系，就要用到卷积运算。\r\n复频域。\r\ns=jw，当中的j是复数单位，所以使用的是复频域。通俗的解释方法是，因为系统中有电感X=jwL、电容 X=1/jwC，物理意义是，系统H(s)对不同的频率分量有不同的衰减，即这种衰减是发生在频域的，所以为了与时域区别，引入复数的运算。但是在复频域计算的形式仍然满足欧姆定理、KCL、KVL、叠加法。\r\n负的频率。\r\n之所以会出现负的频率，这只是数学运算的结果，只存在于数学运算 中，实际中不会有负的频率。\r\n\r\n\r\n卷积的过程就是相当于把信号分解为无穷多的冲击信号，\r\n然后进行冲击响应的叠加。\r\n \r\n有一个七品县令，喜欢用打板子来惩戒那些市井无赖，而且有个惯例：如果没犯大罪，只打一板，释放回家，以示爱民如子。\r\n\r\n有一个无赖，想出人头地却没啥指望，心想：既然扬不了善名，出恶名也成啊。怎么出恶名？炒作呗！怎么炒作？找名人呀！他自然想到了他的行政长官——县令。\r\n\r\n\r\n无赖于是光天化日之下，站在县衙门前撒了一泡尿，后果是可想而知地，自然被请进大堂挨了一板子，然后昂首挺胸回家，躺了一天，嘿！身上啥事也没有！第二天 如法炮制，全然不顾行政长管的仁慈和衙门的体面，第三天、第四天......每天去县衙门领一个板子回来，还喜气洋洋地，坚持一个月之久！这无赖的名气已 经和衙门口的臭气一样，传遍八方了！\r\n\r\n\r\n县令大人噤着鼻子，呆呆地盯着案子上的惊堂木，拧着眉头思考一个问题：这三十个大板子怎么不好使捏？......想当初，本老爷金榜题名时，数学可是得了满分，今天好歹要解决这个问题：\r\n\r\n\r\n——人（系统！）挨板子（脉冲！）以后，会有什么表现（输出！）？\r\n\r\n\r\n——费话，疼呗！\r\n\r\n——我问的是：会有什么表现？\r\n\r\n\r\n——看疼到啥程度。像这无赖的体格，每天挨一个板子啥事都不会有，连哼一下都不可能，你也看到他那得意洋洋的嘴脸了（输出0）；如果一次连揍他十个板子， 他可能会皱皱眉头，咬咬牙，硬挺着不哼（输出1）；揍到二十个板子，他会疼得脸部扭曲，象猪似地哼哼（输出3）；揍到三十个板子，他可能会象驴似地嚎叫， 一把鼻涕一把泪地求你饶他一命（输出5）；揍到四十个板子，他会大小便失禁，勉强哼出声来（输出1）；揍到五十个板子，他连哼一下都不可能（输出0）—— 死啦！\r\n\r\n\r\n县令铺开坐标纸，以打板子的个数作为X轴，以哼哼的程度（输出）为Y轴，绘制了一条曲线：\r\n\r\n\r\n——呜呼呀！这曲线象一座高山，弄不懂弄不懂。为啥那个无赖连挨了三十天大板却不喊绕命呀？\r\n\r\n\r\n——呵呵，你打一次的时间间隔（Δτ=24小时）太长了，所以那个无赖承受的痛苦程度一天一利索，没有叠加，始终是一个常数；如果缩短打板子的时间间隔 （建议Δτ=0.5秒），那他的痛苦程度可就迅速叠加了；等到这无赖挨三十个大板（t=30）时，痛苦程度达到了他能喊叫的极限，会收到最好的惩戒效果， 再多打就显示不出您的仁慈了。\r\n\r\n\r\n——还是不太明白，时间间隔小，为什么痛苦程度会叠加呢？\r\n\r\n\r\n——这与人（线性时不变系统）对板子（脉冲、输入、激励）的响应有关。什么是响应？人挨一个板子后，疼痛的感觉会在一天（假设的，因人而异）内慢慢消失 （衰减），而不可能突然消失。这样一来，只要打板子的时间间隔很小，每一个板子引起的疼痛都来不及完全衰减，都会对最终的痛苦程度有不同的贡献：\r\n\r\nt个大板子造成的痛苦程度=Σ(第τ个大板子引起的痛苦*衰减系数)[衰减系数是（t-τ）的函数，仔细品味]\r\n\r\n数学表达为：y(t)=∫T(τ)H(t-τ)\r\n\r\n\r\n——拿人的痛苦来说卷积的事，太残忍了。除了人以外，其他事物也符合这条规律吗？\r\n\r\n\r\n——呵呵，县令大人毕竟仁慈。其实除人之外，很多事情也遵循此道。好好想一想，铁丝为什么弯曲一次不折，快速弯曲多次却会轻易折掉呢？\r\n\r\n\r\n——恩，一时还弄不清，容本官慢慢想来——但有一点是明确地——来人啊，将撒尿的那个无赖抓来，狠打40大板！', 4, 2, 0, '2024-10-27 15:32:05', '2024-10-27 15:32:05', 0);

-- ----------------------------
-- Table structure for news_type
-- ----------------------------
DROP TABLE IF EXISTS `news_type`;
CREATE TABLE `news_type`  (
  `tid` int NOT NULL AUTO_INCREMENT COMMENT '类型id',
  `tname` varchar(10) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '类型描述',
  PRIMARY KEY (`tid`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of news_type
-- ----------------------------
INSERT INTO `news_type` VALUES (1, '前端开发');
INSERT INTO `news_type` VALUES (2, '后端开发');
INSERT INTO `news_type` VALUES (3, '数学');
INSERT INTO `news_type` VALUES (4, '物理');
INSERT INTO `news_type` VALUES (5, '其他');

-- ----------------------------
-- Table structure for news_user
-- ----------------------------
DROP TABLE IF EXISTS `news_user`;
CREATE TABLE `news_user`  (
  `uid` int NOT NULL AUTO_INCREMENT COMMENT '用户id',
  `username` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户登录名',
  `user_pwd` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户登录密码密文',
  `nick_name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户昵称',
  PRIMARY KEY (`uid`) USING BTREE,
  UNIQUE INDEX `username_unique`(`username` ASC) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 10 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of news_user
-- ----------------------------
INSERT INTO `news_user` VALUES (1, 'zhangsan', 'e10adc3949ba59abbe56e057f20f883e', '张三');
INSERT INTO `news_user` VALUES (2, 'lisi', 'e10adc3949ba59abbe56e057f20f883e', '李四');
INSERT INTO `news_user` VALUES (9, 'liuzhiyou', '944d860c49819a2b5980dc9486c78100', '刘芷悠');

SET FOREIGN_KEY_CHECKS = 1;
